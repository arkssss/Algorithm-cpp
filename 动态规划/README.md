## 动态规划(Dynamic Programming)

###1. 子问题划分

动态规划和递归都是利用划分问题到若干的子问题, 从而求出最后的结果. 而相比于递归的时间复杂度O(2$^n$), DP的时间复杂度可以降到O(n), 是因为, 动态规划在处理overlap的问题的时候, 会只事先存储之前已经出现过的值, 而递归则不会.

以佛波那契数列为例子 :

 ~~~
1 1 2 3 5 8 13 ....
 ~~~

F(n+2) = F(n) + F(n+1), 当以递归的方法调用的时候 : 例如计算F(8)

F(8) = F(7) + F(6) = F(6) + F(5) + F(5) + F(4) = ...

此时F(5) 则出现了overlap.

**递归的实现种** : F(5) 依然是会被计算两次, 不会去存储之前的计算结果, 这是一种 top-to-bottom 的结构

**动态规划的实现种** : 出现过的子问题的解会被记录(空间换时间), 从而将O(2$^{n}$) 的时间复杂度降到了 O(n) , 这是一种 bottom-to-top的结构





### 2. 记忆化递归和动态规划的区别

以斐波那契数列为例子

* 递归 : 

  ~~~c++
  // return第n个斐波那契数
  int F(int n){
      if(n<=2) return 1;
      return F(n-1) + F(n-2);
  }
  ~~~

* 记忆化递归 : 

  ~~~c++
  int F(int n){
      if(n<=2) return 1;
      if (n not in men){
          men[n] = F(n-1) + F(n-2);
      }	
  	return men[n];
  }
  ~~~

* 动态规划 :

  ~~~c++
  // 相比于递归, DP使用的是数组记录
  // 此时时间复杂度和空间复杂度都是N
  int F(int n){
      dp[1] = 1; dp[2] = 1;
      for(int i=3; i<=n;i++){
          de[i] = dp[i-1] + dp[i-2];
      }
      return dp[n]
  }
  
  ~~~

  ~~~c++
  // 进一步缩小空间复杂度
  // 此时空间复杂度仅有1
  int F(int n){
      int dp = dp1 = d2 = 1;
      for(int i=3; i<=n; i++){
          dp = dp1 + dp2;
          // move forward
          dp1 = dp2;
  		dp2 = dp;
      }
      return dp;
  }
  
  ~~~

  **Tips : ** DP 相比于merge排序思想, 都是先从子问题开始求解, 但是merge中没有overlap, 即没有重叠的子问题

[知乎 : 什么是动态规划](https://www.zhihu.com/question/23995189)

> 所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！
> 每个阶段只有一个状态->递推；
> 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
> 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
> 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。





### 3. 拆分为子问题的思想 

例如 题目:



给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

找到一个最优的子数组

==>  以每个点算以该点为结尾的字序列的最优子数组 

==>  最优子数组的则为每个点为结尾的子数组的最大值

**记函数 f(n) 为以n为终点的子序列的最大和值, 那么f(n)必然为max(f(n-1)+nums[n], nums[n])**

即**以n为终点**的子序列的最大和值, 只有以下两种情况: 

* 以n-1点为终点的子序列的最大和值加上n点的值
* 就是n点的值

所有此时递推公式就是 **f(n) = max(f(n-1)+nums[n], nums[n]) **, 从而可以求出 (f1,f2,f3,....fn)

那么, 最大的连续子序列的和就是 : Max(f1,f2,f3,....fn) . 极为问题的解






















